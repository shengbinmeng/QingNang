//请求xml数据文件格式。
//每次用户新添加了药品（不管是通过扫描一维码还是手工输入一维码），即使该药的xml在本地已经存在，也需要发送该请求。
{
	"v":1,	//协议版本号
	"op":1,	//请求码。
	"uid":"",	//用户唯一标识，格式为："android设备机器码/用户姓名"。
	"dt":
	[
		{
		"pd":"",	//请求的药品一维码。
		"ow":true|false,	//本地是否已经有了。true表示已经有了，false表示没有需要服务器给xml。
		},
		{
		"pd":"",
		"ow":true|false,
		},
		......,
	]
}

//服务器响应xml数据文件请求的应答。服务器只应答上面请求中"ow"为false的那些药品。
{
	"cs":true|fase,	//服务器是否成功处理。
	"dt":	//该数组存放成功找到xml的药品的信息。
	[
		{
		"pd":"",	//药品一维码。
		"xmldt":"",	//字符串形式保存的xml文件内容。
		},
		{
		"pd":"",
		"xmldt":"",
		},
		......,
	],
	"nf":	//该数组存放未查询到的药品的扫描码。
	[
		"patchcode","patchcode",.....,
	],
	"ul":true|fase	//是否需要上传所有本地已经存在的xml的扫描码。true表示是，false表示否。
}

//当用户添加了新的提醒都需要发送这些文本数据至服务器。
{
	"v":1,	//协议版本号
	"op":2,	//请求码。
	"uid":"",	//用户唯一标识，格式为："android设备机器码/用户姓名"。
	"dt":
	[
		{
		"pd":"",	//设置提醒的药品一维码。
		"tp":0|1|2|3|4|5,	//提醒类型。
		"nb":3,	//用药数量。
		"st":"2012-12-12|2012-12-12 12:22:33",	//如果是规律用药，则是前面的格式（即只有年月日）表示开始时间；如果是按需用药，则是后面的格式，有具体到时间。如果有多个时间，则用"/"隔开，如2012-12-12 12:22:33/2012-12-12 12:22:34。
		"et":"2012-12-21",			//如果是规律用药，则是该格式；如果是按需用药，则该项为null。
		},
		{
		"pd":"",
		"tp":0|1|2|3|4|5,
		"nb":3,
		"st":"2012-12-12|2012-12-12 12:22:33",
		"et":"2012-12-21",
		},
		......,
	]
}

//添加了新的提醒后的服务器响应。
{
	"cs":true|fase,	//服务器是否成功处理。
}

//请求图片的请求格式。1.如果用户自己拍摄了本地的照片或者用户设置了不从服务器获取图片（因为这个比较耗流量，因此应当有这么个设计），则忽略此请求。2.如果用户没有自己拍摄并设置了需要从服务器获取照片，那么android端则自动发起每一个没有图片的药的图片请求。
{
	"v":1,	//协议版本号
	"op":3,	//请求码。
	"dt":"patchcode"	//需要照片的药品的扫描码。
}

//请求照片的应答格式。
{
	"cs":true|fase,	//服务器是否成功处理。
	"dt":	//图片实际数据。由于json格式里面，默认不支持byte类型，但是在pc上还是将其按照一个字节一个字节传下去。字节的值为0-255。
	[
		byte,byte,byte,....,
	],
	"tp":"jpg|..."		//图片类型。仅仅是该图片在Windows下的扩展名。
}

//请求推荐药品。
{
	"v":1,	//协议版本号
	"op":4,	//请求码。
	"uid":"",	//用户唯一标识，格式为："android设备机器码/用户姓名"。
	"dt":	//上一次请求推荐药品时应答的"nf"数组里面的内容。
	[
		"patchcode","patchcode",.....,
	]
}

//请求推荐药品应答。注，获取了推荐药品应答之后，需要再根据本地没有的xml，再发起一个请求xml的请求。
{
	"cs":true|fase,	//服务器是否成功处理。
	"nf":	//该数组存放推荐药品的排列顺序。如果本地有的patchcode，在此列表中没有了，则不显示那些patchcode。
	[
		"patchcode","patchcode",.....
	]
}

//查询软件更新。每次启动软件时check。
{
	"v":1,	//协议版本号
	"op":5,	//是否需要软件更新。
	"uid":"",	/用户唯一标识，格式为："android设备机器码/用户姓名"。
	"vr":""	//本机的软件版本号。
}

//查询软件更新应答。
{
	"cs":true|fase,	//服务器是否成功处理。
	"ud":true|fase,	//如果需要更新，则为true，否则为false。
	"vr":"",		//如果ud=true，则这里为新软件的版本号。
	"ul":true|fase	//是否需要上传所有本地已经存在的xml的扫描码。true表示是，false表示否。
}

//上传本地存在的所有xml文件的扫描码。
{
	"v":1,	//协议版本号
	"op":6|7,	//上传本地的所有xml的扫描码。如果op=6，表示Server端的ul位置位而发起，op=7，表示客户端由用户发起。（比如推荐删除哪些药品的时候）。
	"dt":
	[
		"patchcode","patchcode","patchcode",......,
	]
}

//服务器应答上传本地存在的所有xml文件的扫描码。
{
	"cs":true|fase,	//服务器是否成功处理。
	"dt":	//需要本地删除xml的药品的扫描码。
	[
		"patchcode","patchcode","patchcode",......,
	],
	"nd":	//表示如上的所有xml是否是必须删除，为一个8位的整数，0b00000000，从右至左，第一位表示是否必须删除（如果为1表示无条件删除该xml，0表示客户端自己判断，主要根据该xml下载时间，如超过3个月没有被访问，则将其删除；否则不用删除。）；第二位表示如果删除该xml的情况下，是否删除图片，包括用户自己照的图片；1表示需要删除，0表示不删除。是这样的：为了避免每个android端软件下载了xml但是服务器上对应的xml文件因为其他原因被更新，那么这个时候，该药品就会出现在上面的patchcode数组中，并且这个时候的xml对应的项在下面这个数组中就为true，表示必须删除了再从服务器上获取。另外而可能服务器上会探测到某些android客户端异常，比如一直在下载我们的xml资料，这个是比较严重的问题，那么服务器端就会发送指令下去，将最早下载的xml删除。
	[
		1,1,1,....,
	]
}

//修改用户名
{
	"v":1,	//协议版本号
	"op":8,	//操作码。
	"uido":"",	//修改前的uid。
	"uid":""	//修改后的uid。
}

//修改用户名应答
{
	"cs":true|fase	//服务器是否成功处理。
}